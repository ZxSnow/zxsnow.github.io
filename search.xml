<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Basic Usage Reference</title>
    <url>/2021/09/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<span id="more"></span>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>中文测试<br>
其中程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生， 随线程而灭， 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化， 但在基于概念模型的讨论里， 大体上可以认为是编译期可知的） ， 因此这</p>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>垃圾收集策略</title>
    <url>/2021/09/26/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="一、垃圾收集策略"><a class="header-anchor" href="#一、垃圾收集策略">¶</a>一、垃圾收集策略</h3>
<span id="more"></span>
<p>主要问题：</p>
<ul>
<li>收什么？</li>
<li>什么时候收？</li>
<li>怎么收？</li>
</ul>
<h4 id="1-哪些内存需要回收？"><a class="header-anchor" href="#1-哪些内存需要回收？">¶</a>1. 哪些内存需要回收？</h4>
<p>​	其中程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生， 随线程而灭， 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化， 但在基于概念模型的讨论里， 大体上可以认为是编译期可知的） ， 因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题， 当方法结束或者线程结束时， 内存自然就跟随着回收了。</p>
<p>​	而<strong>Java堆</strong>和<strong>方法区</strong>这两个区域则有着很显著的不确定性： 一个接口的多个实现类需要的内存可能会不一样， 一个方法所执行的不同条件分支所需要的内存也可能不一样， 只有处于运行期间， 我们才能知道程序究竟会创建哪些对象， 创建多少个对象， 这部分内存的分配和回收是动态的。 垃圾收集器所关注的正是这部分内存该如何管理。</p>
<h5 id="1-2-方法区的回收"><a class="header-anchor" href="#1-2-方法区的回收">¶</a>1.2 方法区的回收</h5>
<p>​	方法区的垃圾收集主要回收两部分内容： <strong>废弃的常量</strong>和<strong>不再使用的类型</strong>。</p>
<blockquote>
<p>​	回收废弃常量与回收Java堆中的对象非常类似。 举个常量池中字面量回收的例子， 假如一个字符串“java”曾经进入常量池中， 但是当前系统又没有任何一个字符串对象的值是“java”， 换句话说， 已经没有任何字符串对象引用常量池中的“java”常量， 且虚拟机中也没有其他地方引用这个字面量。  如果在这时发生内存回收， 而且垃圾收集器判断确有必要的话， 这个“java”常量就将会被系统清理出常量池。 常量池中其他类（接口） 、 方法、 字段的符号引用也与此类似。</p>
</blockquote>
<p>判断一个类是否废弃需满足以下三个条件：</p>
<ul>
<li>该类的所有实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景， 如<br>
OSGi、 JSP的重加载等， 否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方<br>
法。</li>
</ul>
<p>注：满足条件只是允许被回收，不是必然会回收。HotSpot VM提供了参数进行控制，<code>-Xnoclassgc  </code>还可以使用-verbose： class以及-XX： +TraceClass-Loading、 -XX：+TraceClassUnLoading查看类加载和卸载信息， 其中-verbose： class和-XX： +TraceClassLoading可以在Product版的虚拟机中使用， -XX： +TraceClassUnLoading参数需要FastDebug版[1]的虚拟机支持。</p>
<p>​	在大量使用反射、 动态代理、 CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 通常都需要Java虚拟机具备类型卸载的能力， 以保证不会对方法区造成过大的内存压力。</p>
<h4 id="2-什么时候回收？"><a class="header-anchor" href="#2-什么时候回收？">¶</a>2. 什么时候回收？</h4>
<h5 id="2-1-对象死亡判断方法"><a class="header-anchor" href="#2-1-对象死亡判断方法">¶</a>2.1 对象死亡判断方法</h5>
<h6 id="2-1-1-引用计数法（Reference-Counting）"><a class="header-anchor" href="#2-1-1-引用计数法（Reference-Counting）">¶</a>2.1.1 引用计数法（Reference Counting）</h6>
<p>​	在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>​	But！单纯的引用计数很难决绝对象之间的相互循环引用问题。</p>
<h6 id="2-1-2-可达性分析算法"><a class="header-anchor" href="#2-1-2-可达性分析算法">¶</a>2.1.2 可达性分析算法</h6>
<p>​	这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集， 从这些节点开始， 根据引用关系向下搜索， 搜索过程所走过的路径称为“引用链”（Reference Chain） ， 如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。</p>
<p>​	要真正宣告一个对象死亡， <strong>至少要经历两次标记过程</strong>。</p>
<blockquote>
<p>​	如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记， 随后进行一次筛选， 筛选的条件是此对象是否有必要执行finalize()方法。 假如对象没有覆盖finalize()方法， 或者finalize()方法已经被虚拟机调用过， 那么虚拟机将这两种情况都视为“没有必要执行”。</p>
</blockquote>
<p>可作为GC Roots的对象：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表） 中引用的对象， 譬如各个线程被调用的方法堆栈中使用到的<br>
参数、 局部变量、 临时变量等。</li>
<li>在方法区中类静态属性引用的对象， 譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象， 譬如字符串常量池（String Table） 里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法） 引用的对象  。</li>
<li>Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如<br>
NullPointExcepiton、 OutOfMemoryError） 等， 还有系统类加载器 。</li>
<li>所有被同步锁（synchronized关键字） 持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等。</li>
</ul>
<p>​	除了这些固定的GC Roots集合以外， 根据用户所选用的垃圾收集器以及当前回收的内存区域不<br>
同， 还可以有其他对象“临时性”地加入， 共同构成完整GC Roots集合。</p>
<blockquote>
<p>​	譬如后文将会提到的分代收集和局部回收（Partial GC） ， 如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集） ， 必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的） ， 更不是孤立封闭的， 所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用， 这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去， 才能保证可达性分析的正确性。</p>
</blockquote>
<h5 id="2-2-对象引用"><a class="header-anchor" href="#2-2-对象引用">¶</a>2.2 对象引用</h5>
<p>JDK1.2之前的<strong>传统定义</strong>：</p>
<p>​	如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址， 就称该reference数据是代表某块内存、 某个对象的引用。一个对象在这种定义下只有“被引用”或者“未被引用”两种状态。无法描述一些其他类型的对象，譬如我们希望能描述一类对象： 当内存空间还足够时， 能保留在内存之中， 如果内存空间在进行垃圾收集后仍然非常紧张， 那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应用场景。</p>
<p>对传统定义的<strong>扩充</strong>：</p>
<p>​	将引用分为强引用（Strongly Reference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强度依次逐渐减弱 。</p>
<h6 id="强引用"><a class="header-anchor" href="#强引用">¶</a>强引用</h6>
<p>​	强引用是最传统的“引用”的定义， 是指在程序代码之中普遍存在的引用赋值， 即类似 <code> Object obj = new Object()</code>这种引用关系。 无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。</p>
<h6 id="软引用"><a class="header-anchor" href="#软引用">¶</a>软引用</h6>
<p>​	软引用是用来描述一些还有用， 但非必须的对象。 只被软引用关联着的对象， 在系统将要发生内<br>
存溢出异常前， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，<br>
才会抛出内存溢出异常。 在JDK 1.2版之后提供了<strong>SoftReference</strong>类来实现软引用。</p>
<h6 id="弱引用"><a class="header-anchor" href="#弱引用">¶</a>弱引用</h6>
<p>弱引用也是用来描述那些非必须对象， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只<br>
能生存到下一次垃圾收集发生为止。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了<strong>WeakReference</strong>类来实现弱引用。</p>
<h6 id="虚引用"><a class="header-anchor" href="#虚引用">¶</a>虚引用</h6>
<p>​	虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 一个对象是否有虚引用的<br>
存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的只是<em>为了能在这个对象被收集器回收时收到一个系统通知</em>。 在JDK 1.2版之后提供了<strong>PhantomReference</strong>类来实现虚引用。</p>
<p><img src="https://i.loli.net/2021/06/21/psh9ojAES3abB5Q.png" alt="image-20210621160847064"></p>
<h4 id="3-怎么收？"><a class="header-anchor" href="#3-怎么收？">¶</a>3. 怎么收？</h4>
<h5 id="3-1-垃圾收集算法"><a class="header-anchor" href="#3-1-垃圾收集算法">¶</a>3.1 垃圾收集算法</h5>
<p>​	从如何判定对象消亡的角度出发， 垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference<br>
Counting GC） 和“追踪式垃圾收集”（Tracing GC） 两大类， 这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p>
<h5 id="3-2-分代收集理论"><a class="header-anchor" href="#3-2-分代收集理论">¶</a>3.2 分代收集理论</h5>
<p>两个分代假说：</p>
<ul>
<li>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
</ol>
</li>
<li>
<ol start="2">
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ol>
</li>
</ul>
<p>​	由这两个假说奠定了多种垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（熬过GC的次数）分配到不同的区域中存储。</p>
<blockquote>
<p>​	显而易见， 如果一个区域中大多数对象都是朝生夕灭， 难以熬过垃圾收集过程的话， 那么把它们集中放在一起， 每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象， 就能以较低代价回收到大量的空间； 如果剩下的都是难以消亡的对象， 那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域， 这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
</blockquote>
<p>​	在Java堆划分出不同的区域之后， 垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“<strong>Minor GC</strong>”“<strong>Major GC</strong>”“<strong>Full GC</strong>”这样的回收类型的划分； 也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。</p>
<p>​	但是只根据这两个假说将java堆划分成新生代、老年代是不够的，仍会存在跨代引用的问题。会导致可达性分析时遍历某一代所有对象。</p>
<ul>
<li>
<ol start="3">
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
</li>
</ul>
<p>​	依据这条假说， 我们就不应再为了少量的跨代引用去扫描整个老年代， 也不必浪费空间专门记录<br>
每一个对象是否存在及存在哪些跨代引用， 只需在新生代上建立一个全局的数据结构（ 该结构被称<br>
为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干小块， 标识出老年代的哪一块内存会存在跨代引用。 此后当发生Minor GC时， 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。而不是去搜索整个老年代去查找GC Roots。</p>
<h6 id="名词定义"><a class="header-anchor" href="#名词定义">¶</a>名词定义</h6>
<p>部分收集（ Partial GC） ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为：<br>
■<strong>新生代收集</strong>（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。<br>
■<strong>老年代收集</strong>（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有<font color='red'>CMS收集器</font>会有单<br>
独收集老年代的行为。 另外请注意“Major GC”现在有点混淆， 在不同资料上常有不同所指。<br>
■<strong>混合收集</strong>（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有<font color='red'>G1收集器</font>会有这种行为。<br>
整堆收集（ Full GC） ： 收集整个Java堆和方法区的垃圾收集。</p>
<h5 id="3-3-标记-清除算法（Mark-Sweep）"><a class="header-anchor" href="#3-3-标记-清除算法（Mark-Sweep）">¶</a>3.3 标记-清除算法（Mark-Sweep）</h5>
<p>​	算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象， 在标记完成后， 统一回收掉所有被标记的对象， 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。 标记过程就是对象是否属于垃圾的判定过程。</p>
<h6 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h6>
<ul>
<li>执行效率不稳定，执行效率随对象数量的增多而降低</li>
<li>内存空间的碎片化问题，标记、清楚之后会产生大量不连续的内存碎片</li>
</ul>
<h5 id="3-4-标记-复制算法（Mark-Copy）"><a class="header-anchor" href="#3-4-标记-复制算法（Mark-Copy）">¶</a>3.4 标记-复制算法（Mark-Copy）</h5>
<p>​	常用于新生代！</p>
<p>​	“半区复制”（Semispace Copying） 的垃圾收集算法， 它将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。 如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销， 但对于多数对象都是可回收的情况， 算法需要复制的就是占少数的存活对象， 而且每次都是针对整个半区进行内存回收， 分配内存时也就不用考虑有空间碎片的复杂情况， 只要移动堆顶指针， 按顺序分配即可。  不过其缺陷也显而易见， 这种复制回收算法的代价是将可用内存缩小为了原来的一半， 空间浪费。</p>
<h6 id="进阶"><a class="header-anchor" href="#进阶">¶</a>进阶</h6>
<p>​	Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存<strong>只使用Eden</strong>和<strong>其中一块Survivor</strong>（另一块做数据保留）。 发生垃圾搜集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8∶ 1， 也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%） ， 只有一个Survivor空间， 即10%的新生代是会被“浪费”的。 当然， 98%的对象可被回收仅仅是“普通场景”下测得的数据， 任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活， 因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计， 当Survivor空间不足以容纳一次Minor GC之后存活的对象时， 就需要依赖其他内存区域（实际上大多就是老年代） 进行分配担保（Handle Promotion）。</p>
<p>​	内存的分配担保也一样， 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象， 这些对象便将通过分配担保机制直接进入老年代， 这对虚拟机来说就是安全的。  （TODO  书3.8.5）</p>
<p>​	标记-复制算法在对象存活率较高时就要进行较多的复制操作， 效率将会降低。 更关键的是， 如果<br>
不想浪费50%的空间， 就需要有额外的空间进行分配担保， 以应对被使用的内存中所有对象都100%存活的极端情况， 所以在老年代一般不能直接选用这种算法。</p>
<h5 id="3-5-标记-整理算法（Mart-Compact）"><a class="header-anchor" href="#3-5-标记-整理算法（Mart-Compact）">¶</a>3.5 标记-整理算法（Mart-Compact）</h5>
<p>​	针对老年代对象的存亡特征， 1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact） 算法， 其中的标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内<br>
存。</p>
<p>​	标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动式的。如果移动存活对象， 尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作， 而且这种对象移动操作必须全程暂停用户应用程序才能进行。<strong>Stop The World</strong>  。</p>
<p>​	但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话， 弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。是否移动对象都存在弊端， <strong>移动则内存回收时会更复杂</strong>， <strong>不移动则内存分配时会更复杂</strong>。</p>
<p>​	HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的， 而关注延迟的CMS收集器则是基于标记-清除算法的 。另外， 还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担， 做法是让虚拟机平时多数时间都采用标记-清除算法， 暂时容忍内存碎片的存在， 直到内存空间的碎片化程度已经大到影响对象分配时， 再采用标记-整理算法收集一次， 以获得规整的内存空间。 前面提到的基于标记-清除算法的<strong>CMS收集器</strong>面临空间碎片过多时采用的就是这种处理办法。</p>
<h5 id="三种算法对比"><a class="header-anchor" href="#三种算法对比">¶</a>三种算法对比</h5>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Mark-Sweep</th>
<th style="text-align:center">Mark-Copy</th>
<th style="text-align:center">Mark-Compat</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">思路</td>
<td style="text-align:center">先标记，然后删除待回收对象</td>
<td style="text-align:center">将区域分为两部分，每次只使用其中一块，回收时，将所有仍存活对象复制到另一块，然后把一整块清理掉</td>
<td style="text-align:center">先标记，然后将所有存活的对象都移动到内存的一段，清理掉边界之外的</td>
</tr>
<tr>
<td style="text-align:center">速度</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">最快</td>
<td style="text-align:center">最慢</td>
</tr>
<tr>
<td style="text-align:center">空间开销</td>
<td style="text-align:center">少（会有堆积碎片）</td>
<td style="text-align:center">通常需要活对象的2倍大小（不堆积碎片）</td>
<td style="text-align:center">少（不堆积碎片）</td>
</tr>
<tr>
<td style="text-align:center">移动对象</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">停等时间</td>
<td style="text-align:center">相对较短</td>
<td style="text-align:center"></td>
<td style="text-align:center">Stop the world</td>
</tr>
</tbody>
</table>
<h4 id="二、HotSpot算法细节"><a class="header-anchor" href="#二、HotSpot算法细节">¶</a>二、HotSpot算法细节</h4>
<h5 id="1-根节点枚举"><a class="header-anchor" href="#1-根节点枚举">¶</a>1. 根节点枚举</h5>
<h6 id="1-1-做什么"><a class="header-anchor" href="#1-1-做什么">¶</a>1.1 做什么</h6>
<p>可达性算法中的从GC Roots集合找引用链。</p>
<p>查找目标：固定可作为GC Roots的节点：</p>
<ul>
<li>全局性的引用（如常量或类静态属性）</li>
<li>执行上下文（例如栈帧中的本地变量表）</li>
</ul>
<p>​	根节点枚举这个步骤时间上必须要停顿，因为要确保一致性，要保证在进行根节点枚举时，根节点集合的对象引用关系不能发生变化。如果不能保证，分析结果的准确性也就无法保证，这也是导致垃圾回收过程必须停顿所有用户线程的其中一个重要的原因。</p>
<h6 id="1-2-怎么做"><a class="header-anchor" href="#1-2-怎么做">¶</a>1.2 怎么做</h6>
<p>遍历堆和方法区，查找可作为GC Roots的对象。</p>
<p>前提：基于准确式的内存管理，虚拟机是知道对象引用放在哪里的。</p>
<p>实现：可通过辅助的数据结构OopMap快速获取对象引用。</p>
<p>​	HotSpot里，使用一组成为<strong>OopMap</strong>的数据结构来获取哪些地方存放着对象引用这一信息。一旦类加载动作完成时，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来。即时编译过程中，也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了， 并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
<h6 id="1-3-什么时候做"><a class="header-anchor" href="#1-3-什么时候做">¶</a>1.3 什么时候做</h6>
<p>​	对象引用关系时刻都在发生变化，如果每一次都记录一个OopMap代价十分高昂，因此引入“安全点”来决定用户程序执行到什么位置才可以暂停以进行垃圾收集。</p>
<p><strong>安全点选取标准</strong></p>
<p>​	安全点的选定既不能太少以至于让收集器等待时间过长， 也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的， 因为每条指令执行的时间都非常短暂， 程序不太可能因为指令流长度太长这样的原因而长时间执行， “长时间执行”的最明显特征就是指令序列的复用， 例如方法调用、 循环跳转、 异常跳转等都属于指令序列复用， 所以只有具有这些功能的指令才会产生安全点。</p>
<p><strong>安全点同步</strong></p>
<p>发生垃圾收集时，让所有线程（不包括执行JNI调用线程）都跑到最近的安全点，然后停顿下来。</p>
<ul>
<li>
<p>抢先式中断</p>
<p>​	抢先式中断不需要线程的执行代码主动去配合， 在垃圾收集发生时， 系统首先把所有用户线程全部中断， 如果发现有用户线程中断的地方不在安全点上， 就恢复这条线程执行， 让它一会再重新中断， 直到跑到安全点上。  （几乎无虚拟机使用这种方式）</p>
</li>
<li>
<p>主动式中断</p>
<p>​	主动式中断的思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的， 另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方， 这是为了检查是否即将要发生垃圾收集， 避免没有足够内存分配新对象。</p>
<p><strong>轮询实现</strong>：</p>
<p>​	由于轮询操作在代码中会频繁出现， 这要求它必须足够高效。 HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。 下面代码清单3-4中的test指令就是HotSpot生成的轮询指令， 当需要暂停用户线程时， 虚拟机把0x160100的内存页设置为不可读， 那线程执行到test指令时就会产生一个自陷异常信号， 然后在预先注册的异常处理器中挂起线程实现等待， 这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。</p>
</li>
</ul>
<p>所有线程按是否获得CPU时间可划分为两类</p>
<ul>
<li>可获得CPU时间，能自己走到安全点，此时可采用主动式中断</li>
<li>处于Sleep或Blocked状态，无法响应虚拟机的中断请求，此时选择安全区（Safe Region）方式</li>
</ul>
<p>​	安全区域是指能够确保在某一段代码片段之中， 引用关系不会发生变化， 因此， 在这个区域中任<br>
意地方开始垃圾收集都是安全的。  当用户线程执行到安全区域里面的代码时， 首先会标识自己已经进入了安全区域， 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。 当线程要离开安全区域时， 它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段） ， 如果完成了， 那线程就当作没事发生过， 继续执行； 否则它就必须一直等待， 直到收到可以离开安全区域的信号为止。</p>
<h6 id="1-4-GC-Roots查找跨代引用"><a class="header-anchor" href="#1-4-GC-Roots查找跨代引用">¶</a>1.4 GC Roots查找跨代引用</h6>
<p>​	垃圾收集器在新生代中建立了名为记忆集（Remembered Set） 的数据结构， 用以避免把整个老年代加进GC Roots扫描范围。事实上，所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题 。</p>
<p>​	记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。  记录全部含跨代引用对象的实现方案， 无论是空间占用还是维护成本都相当高昂。 而在垃圾收集的场景中， 收集器只需要通过记忆集判断出<strong>某一块非收集区域</strong>是否存在有指向了收集区域的指针就可以了， 并不需要了解这些跨代指针的全部细节。 那设计者在实现记忆集的时候， 便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本。</p>
<ul>
<li>
<p><font color='#0769c2'>字长精度</font>：每个记录精确到一个机器字长（就是处理器的寻址位数， 如常见的32位或64位， 这个精度决定了机器访问物理内存地址的指针长度） ， 该字包含跨代指针。</p>
</li>
<li>
<p><font color='#0769c2'>对象精度</font>：每个记录精确到一个对象， 该对象里有字段含有跨代指针。</p>
</li>
<li>
<p><font color='#0769c2'>卡精度</font>：每个记录精确到一块内存区域， 该区域内有对象含有跨代指针。常使用“卡表”的方式实现记忆集合。</p>
<p>卡表（Card Table）最简单的形式可以只是一个字节数组。字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块， 这个内存块被称作“卡页”（Card Page）。一个卡页的内存中通常包含不止一个对象， 只要卡页内有一个（或更多） 对象的字段存在着跨代指针， 那就将对应卡表的数组元素的值标识为1， 称为这个元素变脏（Dirty） ， 没有则标识为0。 在垃圾收集发生时， 只要筛选出卡表中变脏的元素， 就能轻易得出哪些卡页内存块中包含跨代指针， 把它们加入GC Roots中一并扫描。</p>
</li>
</ul>
<blockquote>
<p>CARD_TABLE [this address &gt;&gt; 9] = 0;</p>
<p>​	一般来说， 卡页大小都是以2的N次幂的字节数， 通过上面代码可以看出HotSpot中使用的卡页是2的9次幂， 即512字节（地址右移9位， 相当于用地址除以512） 。 那如果卡表标识内存区域的起始地址是0x0000的话， 数组CARD_TABLE的第0、 1、 2号元素， 分别对应了地址范围为0x0000～0x01FF、 0x0200～0x03FF、 0x0400～0x05FF的卡页内存块。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/06/22/9tk1rbEHnWjc3JC.png" alt="image-20210622150541676"></p>
<h5 id="卡表数据维护"><a class="header-anchor" href="#卡表数据维护">¶</a>卡表数据维护</h5>
<h6 id="何时？"><a class="header-anchor" href="#何时？">¶</a>何时？</h6>
<p>​	卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时， 其对应的<br>
卡表元素就应该变脏， 变脏时间点原则上应该发生在引用类型字段赋值的那一刻。</p>
<h6 id="怎么变脏的？"><a class="header-anchor" href="#怎么变脏的？">¶</a>怎么变脏的？</h6>
<p>问题等同于如何在对象赋值的那一刻去更新维护卡表呢？</p>
<p>​	假如是解释执行的字节码， 那相对好处理， 虚拟机负责每条字节码指令的执行， 有充分的介入空间； 但在编译执行的场景中呢？ 经过即时编译后的代码已经是纯粹的机器指令流了， 这就必须找到一个在机器码层面的手段， 把维护卡表的动作放到每一个赋值操作之中。</p>
<blockquote>
<p>Java是编译与解释相结合的程序执行</p>
<p><img src="https://i.loli.net/2021/06/22/3rUOQtEZeo5l2nY.png" alt="image-20210622162556697"></p>
<p>参考：<a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html</a></p>
</blockquote>
<p>​	在HotSpot虚拟机里是通过写屏障（Write Barrier） 技术维护卡表状态的。  写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面， 在引用对象赋值时会产生一个环形（Around） 通知， 供程序执行额外的动作， 也就是说赋值的前后都在写屏障的覆盖范畴内。 在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier） ， 在赋值后的则叫作写后屏障（Post-Write Barrier）。</p>
<p>​	应用写屏障后， 虚拟机就会为所有赋值操作生成相应的指令， 一旦收集器在写屏障中增加了更新卡表操作， 无论更新的是不是老年代对新生代对象的引用， 每次只要对引用进行更新， 就会产生额外的开销， 不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p>
<h6 id="卡表的“伪共享问题”"><a class="header-anchor" href="#卡表的“伪共享问题”">¶</a>卡表的“伪共享问题”</h6>
<p>​	伪共享是处理并发底层细节时一种经常需要考虑的问题， 现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的， 当多线程修改互相独立的变量时， 如果这些变量恰好共享同一个缓存行， 就会彼此影响（写回、 无效化或者同步） 而导致性能降低， 这就是伪共享问题。</p>
<p>​	假设处理器的缓存行大小为64字节， 由于一个卡表元素占1个字节， 64个卡表元素将共享同一个缓<br>
存行。 这64个卡表元素对应的卡页总的内存为32KB（64×512字节） ， 也就是说如果不同线程更新的对象正好处于这32KB的内存区域内， 就会导致更新卡表时正好写入同一个缓存行而影响性能。 为了避免伪共享问题， 一种简单的解决方案是不采用无条件的写屏障， 而是先检查卡表标记， 只有当该卡表元素未被标记过时才将其标记为变脏。</p>
<h5 id="并发的可达性分析"><a class="header-anchor" href="#并发的可达性分析">¶</a>并发的可达性分析</h5>
<h6 id="三色标记"><a class="header-anchor" href="#三色标记">¶</a>三色标记</h6>
<ul>
<li><font color='#0769c2'>白色</font>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</li>
<li><font color='#0769c2'>黑色</font>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</li>
<li><font color='#0769c2'>灰色</font>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<p>​	收集器在对象图上标记颜色， 同时用户线程在修改引用关系——即修改对象图的结构， 这样可能出现两种后果。 一种是把原本消亡的对象错误标记为存活，这不是好事， 但其实是可以容忍的， 只不过产生了一点逃过本次收集的浮动垃圾而已， 下次收集清理掉就好。 另一种是把原本存活的对象错误标记为已消亡。当且仅当以下两个条件同时满足时， 会产生“对象消失”的问题， 即原本应该是黑色的对象被误标为白色：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
<p>​	我们要解决并发扫描时的对象消失问题， 只需破坏这两个条件的任意一个即可。 由此分别<br>
产生了两种解决方案： 增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB）</p>
<h6 id="增量更新"><a class="header-anchor" href="#增量更新">¶</a>增量更新</h6>
<p>​	增量更新要破坏的是第一个条件， 当黑色对象插入新的指向白色对象的引用关系时， 就将这个新<br>
插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</p>
<h6 id="原始快照"><a class="header-anchor" href="#原始快照">¶</a>原始快照</h6>
<p>​	原始快照要破坏的是第二个条件， 当灰色对象要删除指向白色对象的引用关系时， 就将这个要删<br>
除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次。 这也可以简化理解为， 无论引用关系删除与否， 都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<p><img src="https://i.loli.net/2021/06/22/CdkQhosZXtn1xjb.png" alt="image-20210622202519145"></p>
<h4 id="三、经典垃圾收集器"><a class="header-anchor" href="#三、经典垃圾收集器">¶</a>三、经典垃圾收集器</h4>
<p><img src="https://i.loli.net/2021/06/23/uIDJNm39pMbeRGi.png" alt="image-20210623104346775"></p>
<h6 id="按分代划分"><a class="header-anchor" href="#按分代划分">¶</a>按分代划分</h6>
<p><img src="https://i.loli.net/2021/06/23/EvAdKMYzPSxTrVs.png" alt="image-20210623105353785"></p>
<h5 id="3-1-Serial收集器"><a class="header-anchor" href="#3-1-Serial收集器">¶</a>3.1 Serial收集器</h5>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
